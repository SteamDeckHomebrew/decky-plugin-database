name: Build Plugins in Parallel

on:
  push:
    branches:
      - main
      - backend-builder
      - concurrent-plugin-builds
    paths:
      - "plugins/**"
      - ".github/workflows/build-plugins.yml"
  pull_request_target:
    branches: ['*']
  workflow_dispatch:
    inputs:
      upload:
        type: boolean
        description: Re-upload the plugins to the store

jobs:
  find_plugins:
    environment:
      name: ${{ (github.ref == 'refs/heads/main' && (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.upload))) && 'env' || 'testing_env' }}
    outputs:
      plugins: ${{ steps.find_plugins.outputs.plugins }}
    runs-on: ubuntu-latest
    steps:
      - name: Get Ref
        id: get_ref
        env:
          isPr: ${{ github.event_name == 'pull_request_target' }}
        run: |
          if [[ $isPr == "true" ]]; then
            REF=refs/pull/${{ github.event.number }}/merge
          else
            REF=${{ github.ref }}
          fi

          echo "ref=$REF" >> $GITHUB_OUTPUT

      - name: Checkout
        if: ${{ !env.ACT }}
        uses: actions/checkout@8230315d06ad95c617244d2f265d237a1682d445
        with:
          ref: ${{ steps.get_ref.outputs.ref }}
          fetch-depth: 9
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Find plugins to be built
        id: find_plugins
        env:
          isPr: ${{ github.event_name == 'pull_request_target' }}
        run: |
          if [[ $isPr == "true" ]]; then
            # Diff with the ref of the target branch
            REF=(origin/${{ github.base_ref }})
          else
            # Diff with previous commit
            REF=(${{ github.ref }} ${{ github.event.before }})
          fi

          git fetch --no-recurse-submodules --depth=3 --all
          workflow_changed=$(git diff --name-only --submodule=diff $REF -- .github/workflows/build-plugins.yml)
          if $workflow_changed; then
            # Workflow changed. Build everything to be safe
            PLUGINS=$(find ./plugins -mindepth 1 -maxdepth 1 -type d -print0 | xargs -0 -n1 -- basename | jq -Rsc 'split("\n")[:-1]')
          else

            git fetch --no-recurse-submodules --depth=3 --all
            PLUGINS=$(git diff --name-only --submodule=diff ${REF[@]} -- plugins | xargs -0 -n1 -- basename | jq -Rsc 'split("\n")[:-2]')
            echo ${REF[@]}
            git diff --name-only --submodule=diff ${REF[@]} -- plugins
            echo $PLUGINS
          fi

          echo "plugins=$PLUGINS" >> $GITHUB_OUTPUT

  build:
    name: Build plugin
    runs-on: ubuntu-latest
    needs:
      - find_plugins
    if: ${{ needs.find_plugins.outputs.plugins != '[]' }}
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        plugin: ${{ fromJSON(needs.find_plugins.outputs.plugins) }}
    outputs:
      name: ${{ steps.set_name.outputs.name }}

    steps:
    - name: Checkout
      if: ${{ !env.ACT }}
      uses: actions/checkout@8230315d06ad95c617244d2f265d237a1682d445
      with:
        ref: ${{ github.event.pull_request.head.sha || github.sha }}
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout plugin submodule
      run: |
        git submodule update --init --depth 1 plugins/${{ matrix.plugin }}

    - name: Pull frontend builder image
      run: docker pull ghcr.io/steamdeckhomebrew/builder:latest

    - name: Pull backend builder image
      run: docker pull ghcr.io/steamdeckhomebrew/holo-base:latest

    - name: Build plugin backend
      run: |
        plugin=${{ matrix.plugin }}
        pushd plugins
        pushd $plugin
        echo "Detecting backend for plugin $plugin"
        dockerfile_exists="false"
        entrypoint_exists="false"
        docker_name="backend-${plugin,,}"
        # [ -d $PWD/backend ] && echo "$(ls -lla $PWD/backend | grep Dockerfile)"
        [ -f $PWD/backend/Dockerfile ] && dockerfile_exists=true
        [ -f $PWD/backend/entrypoint.sh ] && entrypoint_exists=true
        # check for Dockerfile
        if [[ "$dockerfile_exists" == "true" ]]; then
          echo "Grabbing provided dockerfile."
          echo "Building provided Dockerfile."
          docker build -f $PWD/backend/Dockerfile -t "$docker_name" .
          mkdir -p /tmp/output/$plugin/backend/out
          # check entrypoint script exists
          if [[ "$entrypoint_exists" == "true" ]]; then
            echo "Running docker image "$docker_name" with provided entrypoint script."
            docker run --rm -i -v $PWD/backend:/backend -v /tmp/output/$plugin/backend/out:/backend/out --entrypoint /backend/entrypoint.sh "$docker_name"
            mkdir -p /tmp/output/$plugin/bin
            cp -r /tmp/output/$plugin/backend/out/. /tmp/output/$plugin/bin
          else
            echo "Running docker image "$docker_name" with entrypoint script specified in Dockerfile."
            docker run --rm -i -v $PWD/backend:/backend -v /tmp/output/$plugin/backend/out:/backend/out "$docker_name"
            mkdir -p /tmp/output/$plugin/bin
            cp -r /tmp/output/$plugin/backend/out/. /tmp/output/$plugin/bin
          fi
          docker image rm "$docker_name"
          echo "Built $plugin backend"
        # Dockerfile doesn't exist but entrypoint script does, run w/ default image
        elif [[ "$dockerfile_exists" == "false" && "$entrypoint_exists" == "true" ]]; then
          echo "Grabbing default docker image and using provided entrypoint script."
          docker run --rm -i -v $PWD/backend:/backend -v /tmp/output/$plugin/backend/out:/backend/out ghcr.io/steamdeckhomebrew/holo-base:latest
          mkdir -p /tmp/output/$plugin/bin
          cp /tmp/output/$plugin/backend/out/. /tmp/output/$plugin/bin
          echo "Built $plugin backend"
        else
          echo "Plugin $plugin does not have a backend"
        fi
        # ls -lla /tmp/output/$plugin
        popd
        popd

    - name: Build plugin frontend
      run: |
        shopt -s extglob
        pushd plugins
        plugin=${{ matrix.plugin }}
        pushd $plugin
        docker run --rm -i -v $PWD:/plugin -v /tmp/output/$plugin:/out ghcr.io/steamdeckhomebrew/builder:latest
        echo Built $plugin frontend
        ls -lla /tmp/output/$plugin
        cd /tmp/output/$plugin
        popd
        popd

    - name: Zip Plugins
      run: |
        shopt -s dotglob
        mkdir -p /tmp/zips/
        mkdir -p /tmp/output/
        redtext=$'\e[1;31m'
        end=$'\e[0m'
        pushd /tmp/output
        plugin=$(basename ${{ matrix.plugin }})
        zipname=/tmp/$plugin.zip
        echo $plugin

        # Names of the optional files (the license can either be called license or license.md, not both)
        # (head is there to take the first file, because we're assuming there's only a single license file)
        license="$(find $plugin -maxdepth 1 -type f \( -iname "license" -o -iname "license.md" \) -printf '%P\n' | head -n 1)"
        readme="$(find $plugin -maxdepth 1 -type f -iname 'readme.md' -printf '%P\n')"
        haspython="$(find $plugin -maxdepth 1 -type f -name '*.py' -printf '%P\n')"
        # Check if plugin has a bin folder, if so, add "bin" and it's contents to root dir
        hasbin="$(find $plugin -maxdepth 1 -type d -name 'bin' -printf '%P\n')"
        # Check if plugin has a defaults folder, if so, add "default" contents to root dir
        hasdefaults="$(find $plugin -maxdepth 1 -type d -name 'defaults' -printf '%P\n')"
        if [[ "${{ secrets.STORE_ENV }}" == "testing" ]]; then
          long_sha="${{ github.event.pull_request.head.sha || github.sha }}"
          sha=$(echo $long_sha | cut -c1-7)
          cat $plugin/package.json | jq --arg jqsha "$sha" '.version |= . + "-" + $jqsha' | sudo tee $plugin/$sha-package.json
          sudo mv $plugin/$sha-package.json $plugin/package.json
        fi
        # Add required plugin files (and directory) to zip file
        echo "$plugin/dist $plugin/plugin.json $plugin/package.json"
        zip -r $zipname "$plugin/dist" "$plugin/plugin.json" "$plugin/package.json"
        if [ ! -z "$hasbin" ]; then
          echo "$plugin/bin"
          zip -r $zipname "$plugin/bin"
        fi

        if [ ! -z "$haspython" ]; then
          echo "$plugin/*.py"
          find $plugin -maxdepth 1 -type f -name '*.py' -exec zip -r $zipname {} \;
        fi

        if [ ! -z "$hasdefaults" ]; then
          export workingdir=$PWD
          cd $plugin/defaults
          export plugin="$plugin"
          export zipname="$zipname"
          if [ ! -f "defaults.txt" ]; then
            find . -mindepth 1 -type d,f -name '*' -exec bash -c '
              for object do
                outdir="/tmp/output"
                name="$(basename $object)"
                # echo "object = $object, name = $name"
                if [ -e "$object" ]; then
                  sudo mv "$object" $outdir/$plugin/$name
                  moved="$?"
                  # echo "moved = $moved"
                  pushd $workingdir
                  if [ "$moved" = "0" ]; then
                    zip -r $zipname $plugin/$name
                  fi
                  popd
                fi
              done
            ' find-sh {} + ;
          else
            if [[ ! "$plugin" =~ "plugin-template" ]]; then
              printf "${red}defaults.txt found in defaults folder, please remove either defaults.txt or the defaults folder.${end}\n"
            else
              printf "plugin template, allowing defaults.txt\n"
            fi
          fi
          cd "$workingdir"
        fi

        # Check if other files exist, and if they do, add them
        echo "license:$plugin/$license readme:$plugin/$readme"
        if [ ! -z "$license" ]; then
          zip -r $zipname "$plugin/$license"
        fi
        if [ ! -z "$readme" ]; then
          zip -r $zipname "$plugin/$readme"
        fi
        popd

    - name: Upload plugin artifact
      uses: actions/upload-artifact@v3
      with:
        name: ${{ matrix.plugin }}
        path: /tmp/${{ matrix.plugin }}.zip

  find_successful_plugins:
    runs-on: ubuntu-latest
    outputs:
      plugins: ${{ steps.find_plugins.outputs.plugins }}
    needs:
      - find_plugins
      - build

    steps:
      - uses: actions/download-artifact@v3

      - name: Find plugins that built successfully
        id: find_plugins
        run: |
          PLUGINS=$(find . -mindepth 1 -maxdepth 1 -type d -print0 | xargs -0 -n1 -- basename | jq -Rsc 'split("\n")[:-1]')
          echo "plugins=$PLUGINS" >> $GITHUB_OUTPUT

  upload:
    runs-on: ubuntu-latest
    needs:
      - find_plugins
      - build
      - find_successful_plugins
    if: ${{ needs.find_successful_plugins.outputs.plugins != '[]' }}
    environment:
      name: ${{ (github.ref == 'refs/heads/main' && (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.upload))) && 'env' || 'testing_env' }}
    strategy:
      fail-fast: false
      matrix:
        plugin: ${{ fromJSON(needs.find_successful_plugins.outputs.plugins) }}
    steps:
    - uses: actions/download-artifact@v3
      with:
        name: ${{ matrix.plugin }}

    - name: Upload plugin to store
      if: ${{ !env.ACT }}
      id: upload-plugins
      run: |
        shopt -s dotglob
        plugin=${{ matrix.plugin }}
        zipname=$(basename ${plugin}).zip

        metadata=$(unzip -p $zipname $plugin/plugin.json)
        packagejson=$(unzip -p $zipname $plugin/package.json)

        donotupload=$(jq -r '.publish | any(.tags[] == "dnu"; .)' <<< $metadata)
        if [[ "$donotupload" == "false" ]]; then
          curl -X POST \
          -H "Authorization: ${SUBMIT_AUTH_KEY}" \
          -F "name=$(jq -r '.name' <<< $metadata)" \
          -F "author=$(jq -r '.author' <<< $metadata)" \
          -F "description=$(jq -r '.publish.description' <<< $metadata)" \
          -F "tags=$(jq -r '.publish.tags|join(",")' <<< $metadata)" \
          -F "version_name=$(jq -r '.version' <<< $packagejson)" \
          -F "image=$(jq -r '.publish.image' <<< $metadata)" \
          -F "file=@${zipname}" ${STORE_URL}/__submit
        else
          echo "Plugin is designated as 'do not upload', likely a template or CI demonstration."
        fi
      env:
        SUBMIT_AUTH_KEY: ${{ secrets.SUBMIT_AUTH_KEY }}
        STORE_URL: ${{ secrets.STORE_URL }}
